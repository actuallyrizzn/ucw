"""
Wrapper builder for UCW.

This module handles building callable CommandWrapper objects from
CommandSpec specifications.
"""

from typing import Dict, Any

from models import CommandSpec
from wrapper import CommandWrapper


class WrapperBuilder:
    """Builder for CommandWrapper objects."""
    
    def __init__(self, timeout_exec: int = 30):
        self.timeout_exec = timeout_exec
    
    def build_wrapper(self, spec: CommandSpec) -> CommandWrapper:
        """
        Build a CommandWrapper from a CommandSpec.
        
        Args:
            spec: CommandSpec object
            
        Returns:
            CommandWrapper object
        """
        return CommandWrapper(spec.name, spec, timeout=self.timeout_exec)
    
    def generate_mcp_plugin_code(self, spec: CommandSpec) -> str:
        """
        Generate MCP plugin code following the plugin development guide pattern.
        
        Args:
            spec: CommandSpec object
            
        Returns:
            Complete MCP plugin code as string
        """
        template = '''#!/usr/bin/env python3
"""
{command_name} Plugin

Auto-generated plugin for {command_name} command.
Generated by Universal Command Wrapper (UCW).
"""

import argparse
import json
import subprocess
import sys
import time
from typing import Dict, Any


def run(args: Dict[str, Any]) -> Dict[str, Any]:
    """Execute the {command_name} command."""
    try:
        # Build command arguments
        cmd_args = ["{command_name}"]
{argument_handling_code}
{positional_handling_code}
        
        # Execute command
        start_time = time.time()
        result = subprocess.run(
            cmd_args,
            capture_output=True,
            text=True,
            timeout={timeout_exec}
        )
        elapsed = time.time() - start_time
        
        # Return result in SMCP-compatible format
        if result.returncode == 0:
            return {{
                "result": result.stdout,
                "command": " ".join(cmd_args),
                "elapsed": elapsed
            }}
        else:
            return {{
                "error": result.stderr or f"Command failed with return code {{result.returncode}}",
                "command": " ".join(cmd_args),
                "return_code": result.returncode,
                "elapsed": elapsed
            }}
        
    except subprocess.TimeoutExpired:
        return {{
            "error": "Command timed out after {timeout_exec} seconds"
        }}
    except Exception as e:
        return {{
            "error": f"Command execution failed: {{str(e)}}"
        }}


def describe() -> Dict[str, Any]:
    """Return plugin description in SMCP format."""
    return {{
        "plugin": {{
            "name": "{command_name}",
            "version": "1.0.0",
            "description": "Auto-generated plugin for {command_name} command"
        }},
        "commands": [
            {{
                "name": "run",
                "description": "Execute the {command_name} command",
                "parameters": [
{parameter_specs}
                ]
            }}
        ]
    }}


def main():
    """Main entry point for the plugin CLI."""
    parser = argparse.ArgumentParser(
        description="{command_name} Plugin - Auto-generated by UCW",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available commands:
  run    Execute the {command_name} command

Examples:
  python cli.py run{example_args}
        """
    )
    
    # Add --describe flag
    parser.add_argument("--describe", action="store_true", help="Output plugin description in JSON format")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Run command
    run_parser = subparsers.add_parser("run", help="Execute {command_name} command")
{argument_definitions}
{positional_definitions}
    
    args = parser.parse_args()
    
    # Handle --describe flag
    if args.describe:
        print(json.dumps(describe()))
        sys.exit(0)
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    try:
        if args.command == "run":
            # Convert argparse args to dict for run function
            run_args = {{}}
{args_conversion_code}
            # Always call run, even with no args (to show gh help)
            result = run(run_args)
        else:
            result = {{"error": f"Unknown command: {{args.command}}"}}
        
        # Output JSON (no indentation for SMCP compatibility)
        print(json.dumps(result))
        sys.exit(0 if "error" not in result else 1)
        
    except Exception as e:
        print(json.dumps({{"error": str(e)}}))
        sys.exit(1)


if __name__ == "__main__":
    main()
'''
        
        # Generate argument definitions
        argument_definitions = self._generate_argument_definitions(spec)
        
        # Generate positional argument definitions
        positional_definitions = self._generate_positional_definitions(spec)
        
        # Generate argument handling code (for run function)
        argument_handling_code = self._generate_argument_handling_code(spec)
        
        # Generate positional argument handling code (for run function)
        positional_handling_code = self._generate_positional_handling_code(spec)
        
        # Generate args conversion code (argparse args to dict)
        args_conversion_code = self._generate_args_conversion(spec)
        
        # Generate example args string
        example_args = self._generate_example_args(spec)
        
        # Generate parameter specs for --describe
        parameter_specs = self._generate_parameter_specs(spec)
        
        return template.format(
            command_name=spec.name,
            argument_definitions=argument_definitions,
            positional_definitions=positional_definitions,
            argument_handling_code=argument_handling_code,
            positional_handling_code=positional_handling_code,
            args_conversion_code=args_conversion_code,
            example_args=example_args,
            parameter_specs=parameter_specs,
            timeout_exec=self.timeout_exec
        )
    
    def _normalize_dest_name(self, flag: str) -> str:
        """Normalize flag to valid Python attribute name."""
        # Remove leading dashes and slashes
        dest = flag.lstrip('-/')
        
        # Remove angle brackets for positional args (e.g., <COMMAND> -> COMMAND)
        dest = dest.strip('<>')
        
        # Handle empty case
        if not dest:
            dest = 'empty'
        
        # Replace remaining dashes with underscores
        dest = dest.replace('-', '_')
        
        # Handle special characters
        if dest == '?':
            dest = 'question'
        elif dest.startswith('?'):
            dest = 'question_' + dest[1:]
        
        # Ensure it's a valid Python identifier
        if not dest.isidentifier():
            # Replace invalid characters with underscores
            import re
            dest = re.sub(r'[^a-zA-Z0-9_]', '_', dest)
            # Ensure it doesn't start with a number
            if dest and dest[0].isdigit():
                dest = '_' + dest
        
        return dest
    
    def _generate_argument_definitions(self, spec: CommandSpec) -> str:
        """Generate argparse argument definitions."""
        lines = []
        
        # Reserved argparse options that conflict with built-in options
        reserved_options = {'--help', '-h', '--version', '-v'}
        
        for option in spec.options:
            # Skip reserved options to avoid conflicts
            if option.flag in reserved_options:
                continue
                
            dest = self._normalize_dest_name(option.flag)
            if option.is_boolean:
                # Boolean flag
                lines.append(f'    run_parser.add_argument("{option.flag}", action="store_true", dest="{dest}", help="{option.description or ""}")')
            else:
                # Value flag
                lines.append(f'    run_parser.add_argument("{option.flag}", dest="{dest}", help="{option.description or ""}")')
        
        return '\n'.join(lines) if lines else '    pass'
    
    def _generate_argument_handling(self, spec: CommandSpec) -> str:
        """Generate argument handling code."""
        lines = []
        
        # Reserved argparse options that conflict with built-in options
        reserved_options = {'--help', '-h', '--version', '-v'}
        
        for option in spec.options:
            # Skip reserved options to avoid conflicts
            if option.flag in reserved_options:
                continue
                
            dest = self._normalize_dest_name(option.flag)
            if option.is_boolean:
                lines.append(f'        if args.{dest}:')
                lines.append(f'            cmd_args.append("{option.flag}")')
            else:
                lines.append(f'        if hasattr(args, "{dest}") and args.{dest} is not None:')
                lines.append(f'            cmd_args.extend(["{option.flag}", str(args.{dest})])')
        
        return '\n'.join(lines) if lines else '        pass'
    
    def _generate_positional_definitions(self, spec: CommandSpec) -> str:
        """Generate argparse argument definitions for positional args (as optional flags for SMCP compatibility)."""
        lines = []
        
        for arg in spec.positional_args:
            # Normalize argument name for Python variable
            arg_name = self._normalize_dest_name(arg.name).lower()
            
            # Build help text
            help_text = arg.description or f"{arg.name} argument"
            if not arg.required:
                help_text += " (optional)"
            
            # Convert to optional flag format (--command) for SMCP compatibility
            # SMCP passes arguments as --param-name flags, not positional args
            # Make all optional so command can be called with no args (to show help)
            # Use different dest name to avoid conflict with subcommand name 'command'
            flag_name = f"--{arg_name.replace('_', '-')}"
            dest_name = f"arg_{arg_name.replace('-', '_')}"  # Prefix with 'arg_' to avoid conflicts
            
            if arg.variadic:
                # Variadic - can accept multiple values
                lines.append(f'    run_parser.add_argument("{flag_name}", nargs="*", dest="{dest_name}", help="{help_text}")')
            else:
                # Single value - always optional to allow calling command with no args
                lines.append(f'    run_parser.add_argument("{flag_name}", dest="{dest_name}", help="{help_text}")')
        
        return '\n'.join(lines) if lines else '    pass'
    
    def _generate_positional_handling(self, spec: CommandSpec) -> str:
        """Generate positional argument handling code."""
        lines = []
        
        for arg in spec.positional_args:
            arg_name = self._normalize_dest_name(arg.name)
            
            if arg.variadic:
                # Variadic argument - can be a list
                lines.append(f'        if hasattr(args, "{arg_name}") and args.{arg_name}:')
                lines.append(f'            if isinstance(args.{arg_name}, list):')
                lines.append(f'                cmd_args.extend(args.{arg_name})')
                lines.append(f'            else:')
                lines.append(f'                cmd_args.append(str(args.{arg_name}))')
            else:
                # Single argument
                lines.append(f'        if hasattr(args, "{arg_name}") and args.{arg_name} is not None:')
                lines.append(f'            cmd_args.append(str(args.{arg_name}))')
        
        return '\n'.join(lines) if lines else '        pass'
    
    def _generate_argument_handling_code(self, spec: CommandSpec) -> str:
        """Generate argument handling code for the run function (from dict args)."""
        lines = []
        
        # Reserved argparse options that conflict with built-in options
        reserved_options = {'--help', '-h', '--version', '-v'}
        
        for option in spec.options:
            # Skip reserved options to avoid conflicts
            if option.flag in reserved_options:
                continue
                
            # Convert flag to parameter name (--some-flag -> some_flag)
            param_name = self._flag_to_param_name(option.flag)
            
            if option.is_boolean:
                lines.append(f'        if args.get("{param_name}", False):')
                lines.append(f'            cmd_args.append("{option.flag}")')
            else:
                lines.append(f'        if args.get("{param_name}") is not None:')
                lines.append(f'            cmd_args.extend(["{option.flag}", str(args["{param_name}"])])')
        
        return '\n'.join(lines) if lines else '        pass'
    
    def _generate_positional_handling_code(self, spec: CommandSpec) -> str:
        """Generate positional argument handling code for the run function (from dict args)."""
        lines = []
        
        for arg in spec.positional_args:
            param_name = self._normalize_dest_name(arg.name).lower()
            
            if arg.variadic:
                # Variadic argument - can be a list
                lines.append(f'        if args.get("{param_name}"):')
                lines.append(f'            value = args["{param_name}"]')
                lines.append(f'            if isinstance(value, list):')
                lines.append(f'                cmd_args.extend([str(v) for v in value])')
                lines.append(f'            else:')
                lines.append(f'                cmd_args.append(str(value))')
            else:
                # Single argument
                lines.append(f'        if args.get("{param_name}") is not None:')
                lines.append(f'            cmd_args.append(str(args["{param_name}"]))')
        
        return '\n'.join(lines) if lines else '        pass'
    
    def _generate_args_conversion(self, spec: CommandSpec) -> str:
        """Generate code to convert argparse args to dict for run function."""
        lines = []
        
        # Reserved argparse options that conflict with built-in options
        reserved_options = {'--help', '-h', '--version', '-v'}
        
        # Add option arguments
        for option in spec.options:
            if option.flag in reserved_options:
                continue
            param_name = self._flag_to_param_name(option.flag)
            dest = self._normalize_dest_name(option.flag)
            lines.append(f'            if hasattr(args, "{dest}") and args.{dest} is not None:')
            lines.append(f'                run_args["{param_name}"] = args.{dest}')
        
        # Add positional arguments (now passed as flags, so use the dest name with arg_ prefix)
        for arg in spec.positional_args:
            param_name = self._normalize_dest_name(arg.name).lower()
            dest = f"arg_{param_name.replace('-', '_')}"  # Use the dest name with arg_ prefix
            lines.append(f'            if hasattr(args, "{dest}") and args.{dest} is not None:')
            lines.append(f'                run_args["{param_name}"] = args.{dest}')
        
        return '\n'.join(lines) if lines else '            pass'
    
    def _generate_example_args(self, spec: CommandSpec) -> str:
        """Generate example arguments string for help text."""
        parts = []
        for arg in spec.positional_args[:2]:  # Show first 2 positional args
            param_name = self._normalize_dest_name(arg.name).lower()
            parts.append(f' --{param_name.replace("_", "-")} <value>')
        return ''.join(parts)
    
    def _flag_to_param_name(self, flag: str) -> str:
        """Convert flag (--some-flag) to parameter name (some_flag) for dict keys."""
        # Remove leading dashes
        param = flag.lstrip('-/')
        # Replace dashes with underscores
        param = param.replace('-', '_')
        return param
    
    def _generate_parameter_specs(self, spec: CommandSpec) -> str:
        """Generate parameter specifications for --describe output."""
        lines = []
        
        # Reserved argparse options that conflict with built-in options
        reserved_options = {'--help', '-h', '--version', '-v'}
        
        # Add positional arguments (as optional flags for SMCP)
        for arg in spec.positional_args:
            param_name = self._normalize_dest_name(arg.name).lower()
            param_type = self._map_type_hint_to_json_type(arg.type_hint or 'str')
            description = arg.description or f"{arg.name} argument"
            
            lines.append('                    {')
            lines.append(f'                        "name": "{param_name}",')
            lines.append(f'                        "type": "{param_type}",')
            lines.append(f'                        "description": "{description}",')
            # Make them optional so gh can be called with no args to show help
            lines.append('                        "required": False,')
            lines.append('                        "default": None')
            lines.append('                    },')
        
        # Add option arguments
        for option in spec.options:
            if option.flag in reserved_options:
                continue
            param_name = self._flag_to_param_name(option.flag)
            param_type = self._map_type_hint_to_json_type(option.type_hint or 'str')
            description = option.description or f"{option.flag} option"
            
            lines.append('                    {')
            lines.append(f'                        "name": "{param_name}",')
            lines.append(f'                        "type": "{param_type}",')
            lines.append(f'                        "description": "{description}",')
            lines.append('                        "required": False,')
            lines.append('                        "default": None')
            lines.append('                    },')
        
        # Remove trailing comma from last item
        if lines:
            lines[-1] = lines[-1].rstrip(',')
        
        return '\n'.join(lines) if lines else '                    {}'
    
    def _map_type_hint_to_json_type(self, type_hint: str) -> str:
        """Map UCW type hint to JSON Schema type."""
        type_map = {
            'str': 'string',
            'int': 'integer',
            'float': 'number',
            'bool': 'boolean',
            'path': 'string',  # Path is still a string
        }
        return type_map.get(type_hint.lower(), 'string')
