"""
Wrapper builder for UCW.

This module handles building callable CommandWrapper objects from
CommandSpec specifications.
"""

from typing import Dict, Any

from models import CommandSpec
from wrapper import CommandWrapper


class WrapperBuilder:
    """Builder for CommandWrapper objects."""
    
    def __init__(self, timeout_exec: int = 30):
        self.timeout_exec = timeout_exec
    
    def build_wrapper(self, spec: CommandSpec) -> CommandWrapper:
        """
        Build a CommandWrapper from a CommandSpec.
        
        Args:
            spec: CommandSpec object
            
        Returns:
            CommandWrapper object
        """
        return CommandWrapper(spec.name, spec, timeout=self.timeout_exec)
    
    def generate_mcp_plugin_code(self, spec: CommandSpec) -> str:
        """
        Generate MCP plugin code following the plugin development guide pattern.
        
        Args:
            spec: CommandSpec object
            
        Returns:
            Complete MCP plugin code as string
        """
        template = '''#!/usr/bin/env python3
"""
{command_name} Plugin

Auto-generated plugin for {command_name} command.
Generated by Universal Command Wrapper (UCW).
"""

import argparse
import json
import subprocess
import sys
import time
from typing import Dict, Any


def main():
    """Main entry point for the plugin CLI."""
    parser = argparse.ArgumentParser(
        description="{command_name} Plugin - Auto-generated by UCW",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available commands:
  execute    Execute the {command_name} command

Examples:
  python cli.py execute
        """
    )
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Add execute command
    setup_execute_command(subparsers)
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    # Execute the appropriate command
    if args.command == "execute":
        result = execute_command(args)
    else:
        result = {{"status": "error", "error": f"Unknown command: {{args.command}}"}}
    
    # Output JSON result
    print(json.dumps(result, indent=2))


def setup_execute_command(subparsers):
    """Setup the execute command."""
    parser = subparsers.add_parser("execute", help="Execute {command_name} command")
{argument_definitions}


def execute_command(args) -> Dict[str, Any]:
    """Execute the {command_name} command."""
    try:
        # Build command arguments
        cmd_args = ["{command_name}"]
{argument_handling}
        
        # Execute command
        start_time = time.time()
        result = subprocess.run(
            cmd_args,
            capture_output=True,
            text=True,
            timeout={timeout_exec}
        )
        elapsed = time.time() - start_time
        
        return {{
            "status": "success",
            "command": " ".join(cmd_args),
            "stdout": result.stdout,
            "stderr": result.stderr,
            "return_code": result.returncode,
            "elapsed": elapsed
        }}
        
    except subprocess.TimeoutExpired:
        return {{
            "status": "error",
            "error": "Command timed out after {timeout_exec} seconds"
        }}
    except Exception as e:
        return {{
            "status": "error",
            "error": f"Command execution failed: {{str(e)}}"
        }}


if __name__ == "__main__":
    main()
'''
        
        # Generate argument definitions
        argument_definitions = self._generate_argument_definitions(spec)
        
        # Generate argument handling
        argument_handling = self._generate_argument_handling(spec)
        
        return template.format(
            command_name=spec.name,
            argument_definitions=argument_definitions,
            argument_handling=argument_handling,
            timeout_exec=self.timeout_exec
        )
    
    def _normalize_dest_name(self, flag: str) -> str:
        """Normalize flag to valid Python attribute name."""
        # Remove leading dashes and slashes
        dest = flag.lstrip('-/')
        
        # Handle empty case
        if not dest:
            dest = 'empty'
        
        # Replace remaining dashes with underscores
        dest = dest.replace('-', '_')
        
        # Handle special characters
        if dest == '?':
            dest = 'question'
        elif dest.startswith('?'):
            dest = 'question_' + dest[1:]
        
        # Ensure it's a valid Python identifier
        if not dest.isidentifier():
            # Replace invalid characters with underscores
            import re
            dest = re.sub(r'[^a-zA-Z0-9_]', '_', dest)
            # Ensure it doesn't start with a number
            if dest and dest[0].isdigit():
                dest = '_' + dest
        
        return dest
    
    def _generate_argument_definitions(self, spec: CommandSpec) -> str:
        """Generate argparse argument definitions."""
        lines = []
        
        # Reserved argparse options that conflict with built-in options
        reserved_options = {'--help', '-h', '--version', '-v'}
        
        for option in spec.options:
            # Skip reserved options to avoid conflicts
            if option.flag in reserved_options:
                continue
                
            dest = self._normalize_dest_name(option.flag)
            if option.is_boolean:
                # Boolean flag
                lines.append(f'    parser.add_argument("{option.flag}", action="store_true", dest="{dest}", help="{option.description or ""}")')
            else:
                # Value flag
                lines.append(f'    parser.add_argument("{option.flag}", dest="{dest}", help="{option.description or ""}")')
        
        return '\n'.join(lines) if lines else '    pass'
    
    def _generate_argument_handling(self, spec: CommandSpec) -> str:
        """Generate argument handling code."""
        lines = []
        
        # Reserved argparse options that conflict with built-in options
        reserved_options = {'--help', '-h', '--version', '-v'}
        
        for option in spec.options:
            # Skip reserved options to avoid conflicts
            if option.flag in reserved_options:
                continue
                
            dest = self._normalize_dest_name(option.flag)
            if option.is_boolean:
                lines.append(f'        if args.{dest}:')
                lines.append(f'            cmd_args.append("{option.flag}")')
            else:
                lines.append(f'        if hasattr(args, "{dest}") and args.{dest} is not None:')
                lines.append(f'            cmd_args.extend(["{option.flag}", str(args.{dest})])')
        
        return '\n'.join(lines) if lines else '        pass'
